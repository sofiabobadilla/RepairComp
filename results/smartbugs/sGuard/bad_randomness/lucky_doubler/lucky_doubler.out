
> symEvm@1.0.0 dev /sGuard
> node src/index.js "smartbugs/dataset/bad_randomness/lucky_doubler.sol" "results/bad_randomness/lucky_doubler" "LuckyDoubler"

smartbugs/dataset/bad_randomness/lucky_doubler.sol
{ bugFixes:
   { '-@/GKTlHQb\\MADEAKY`^&No=1': 'div_uint256(uint256(hashVal), factor)',
     '0Eh-aVz[9q^3)[H;1_': 'div_uint256(FACTOR * 100, max)',
     '/t,$H/:C_?^oyxYN"di!^y':
      '(unpaidEntries.length = sub_uint256(unpaidEntries.length, 1))',
     '-M4^)`\'XiPdMDDM7q2N4(J^x': 'sub_uint256(unpaidEntries.length, 1)',
     'LiuUepP`[': 'sub_uint256(100, fee)',
     'nOh5c&qD;A]>{o8P5QmLP': 'mul_uint256(dValue, (multiplier))',
     'Dc]AAa_[!JP@.JGVq4G40:v{{+V`ggT': ' function changeFee(uint newFee) nonReentrant_ ',
     ':%I8Q.<aglYM_%T3o)(,ijQNl6c3-NJxHnJ&c': ' function changeMultiplier(uint multi) nonReentrant_ ',
     'J!Qtm}8Jb@!FU>P\\': 'sub_uint256(block.number, 1)',
     'W8W"1GgK~17+0s.v1e!qJ]b^': 'sub_uint256(unpaidEntries.length, 1)',
     '>Wj|/&X+4R3%dE!nhxr@': 'mul_uint256(dValue, (LiuUepP`[))',
     'sj,_.3KwUM%"Zh<.qcPzm,3TtTp': 'div_uint256(nOh5c&qD;A]>{o8P5QmLP, 100)',
     'SV]=2WwNmNw7Uh2[}B6UKM{\'O$peR\'&qs|rs.A': ' function changeOwner(address newOwner) nonReentrant_ ',
     'F!~vm192I}8=~\\Kg%k1]+F': 'sub_uint256(this.balance, balance)',
     '8[U4`~*?X[RcC7Ewi[[JTK{}2Fx5': 'div_uint256((>Wj|/&X+4R3%dE!nhxr@), 100)',
     '{Nm/[w}Z]#[A\\K:)R$2': 'sub_uint256(msg.value, 1 ether)',
     '},Jf^^<C0)I!>zx4,': 'balance = sub_uint256(balance, payout)',
     'tWTf]sTLAV-TUa:+s': 'sub_uint256(entries.length, 1)',
     'jYb+Z6b9f\'gI|j=S&J:4><^Wcc,%?ADb(JS/<TN':
      'balance = add_uint256(balance, 8[U4`~*?X[RcC7Ewi[[JTK{}2Fx5)',
     'B3IjLGhzktx.CraG6c,x3c': 'contract LuckyDoubler  is sGuard ' },
  source:
   '/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xF767fCA8e65d03fE16D4e38810f5E5376c3372A8#code\n * @vulnerable_at_lines: 127,128,129,130,132\n * @author: -\n */\n\n //added pragma version\n\n B3IjLGhzktx.CraG6c,x3c{\n//##########################################################\n//#### LuckyDoubler: A doubler with random payout order ####\n//#### Deposit 1 ETHER to participate                   ####\n//##########################################################\n//COPYRIGHT 2016 KATATSUKI ALL RIGHTS RESERVED\n//No part of this source code may be reproduced, distributed,\n//modified or transmitted in any form or by any means without\n//the prior written permission of the creator.\n\n    address private owner;\n\n    //Stored variables\n    uint private balance = 0;\n    uint private fee = 5;\n    uint private multiplier = 125;\n\n    mapping (address => User) private users;\n    Entry[] private entries;\n    uint[] private unpaidEntries;\n\n    //Set owner on contract creation\n    function LuckyDoubler() {\n        owner = msg.sender;\n    }\n\n    modifier onlyowner { if (msg.sender == owner) _; }\n\n    struct User {\n        address id;\n        uint deposits;\n        uint payoutsReceived;\n    }\n\n    struct Entry {\n        address entryAddress;\n        uint deposit;\n        uint payout;\n        bool paid;\n    }\n\n    //Fallback function\n    function() {\n        init();\n    }\n\n    function init() private{\n\n        if (msg.value < 1 ether) {\n             msg.sender.send(msg.value);\n            return;\n        }\n\n        join();\n    }\n\n    function join() private {\n\n        //Limit deposits to 1ETH\n        uint dValue = 1 ether;\n\n        if (msg.value > 1 ether) {\n\n        \tmsg.sender.send({Nm/[w}Z]#[A\\K:)R$2);\n        \tdValue = 1 ether;\n        }\n\n        //Add new users to the users array\n        if (users[msg.sender].id == address(0))\n        {\n            users[msg.sender].id = msg.sender;\n            users[msg.sender].deposits = 0;\n            users[msg.sender].payoutsReceived = 0;\n        }\n\n        //Add new entry to the entries array\n        entries.push(Entry(msg.sender, dValue, (sj,_.3KwUM%"Zh<.qcPzm,3TtTp), false));\n        users[msg.sender].deposits++;\n        unpaidEntries.push(tWTf]sTLAV-TUa:+s);\n\n        //Collect fees and update contract balance\n        jYb+Z6b9f\'gI|j=S&J:4><^Wcc,%?ADb(JS/<TN;\n\n        uint index = unpaidEntries.length > 1 ? rand(unpaidEntries.length) : 0;\n        Entry theEntry = entries[unpaidEntries[index]];\n\n        //Pay pending entries if the new balance allows for it\n        if (balance > theEntry.payout) {\n\n            uint payout = theEntry.payout;\n\n            theEntry.entryAddress.send(payout);\n            theEntry.paid = true;\n            users[theEntry.entryAddress].payoutsReceived++;\n\n            },Jf^^<C0)I!>zx4,;\n\n            if (index < -M4^)`\'XiPdMDDM7q2N4(J^x)\n                unpaidEntries[index] = unpaidEntries[W8W"1GgK~17+0s.v1e!qJ]b^];\n\n            /t,$H/:C_?^oyxYN"di!^y;\n\n        }\n\n        //Collect money from fees and possible leftovers from errors (actual balance untouched)\n        uint fees = F!~vm192I}8=~\\Kg%k1]+F;\n        if (fees > 0)\n        {\n                owner.send(fees);\n        }\n\n    }\n\n    //Generate random number between 0 & max\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n    // <yes> <report> BAD_RANDOMNESS\n    function rand(uint max) constant private returns (uint256 result){\n        uint256 factor = 0Eh-aVz[9q^3)[H;1_;\n        uint256 lastBlockNumber = J!Qtm}8Jb@!FU>P\\;\n        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\n\n        return uint256((-@/GKTlHQb\\MADEAKY`^&No=1)) % max;\n    }\n\n\n    //Contract management\n    SV]=2WwNmNw7Uh2[}B6UKM{\'O$peR\'&qs|rs.A onlyowner {\n        owner = newOwner;\n    }\n\n    :%I8Q.<aglYM_%T3o)(,ijQNl6c3-NJxHnJ&c onlyowner {\n        if (multi < 110 || multi > 150) throw;\n\n        multiplier = multi;\n    }\n\n    Dc]AAa_[!JP@.JGVq4G40:v{{+V`ggT onlyowner {\n        if (fee > 5)\n            throw;\n        fee = newFee;\n    }\n\n\n    //JSON functions\n    function multiplierFactor() constant returns (uint factor, string info) {\n        factor = multiplier;\n        info = \'The current multiplier applied to all deposits. Min 110%, max 150%.\';\n    }\n\n    function currentFee() constant returns (uint feePercentage, string info) {\n        feePercentage = fee;\n        info = \'The fee percentage applied to all deposits. It can change to speed payouts (max 5%).\';\n    }\n\n    function totalEntries() constant returns (uint count, string info) {\n        count = entries.length;\n        info = \'The number of deposits.\';\n    }\n\n    function userStats(address user) constant returns (uint deposits, uint payouts, string info)\n    {\n        if (users[user].id != address(0x0))\n        {\n            deposits = users[user].deposits;\n            payouts = users[user].payoutsReceived;\n            info = \'Users stats: total deposits, payouts received.\';\n        }\n    }\n\n    function entryDetails(uint index) constant returns (address user, uint payout, bool paid, string info)\n    {\n        if (index < entries.length) {\n            user = entries[index].entryAddress;\n            payout = entries[index].payout / 1 finney;\n            paid = entries[index].paid;\n            info = \'Entry info: user address, expected payout in Finneys, payout status.\';\n        }\n    }\n\n\n}\n',
  wrappers:
   Set {
     'div_uint256',
     'sub_uint256',
     'mul_uint256',
     'nonReentrant_',
     'add_uint256' } }

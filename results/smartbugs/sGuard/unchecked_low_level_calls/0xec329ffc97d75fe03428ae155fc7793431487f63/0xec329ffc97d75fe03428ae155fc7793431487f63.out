
> symEvm@1.0.0 dev /sGuard
> node src/index.js "smartbugs/dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol" "results/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63" "Owned"

smartbugs/dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol
{ bugFixes: {},
  source:
   '/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 30\n */\n\n\ncontract Owned {\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public owner;\n\n    // This contract only defines a modifier and a few useful functions\n    // The function body is inserted where the special symbol "_" in the\n    // definition of a modifier appears.\n    modifier onlyOwner { if (msg.sender == owner) _; }\n\n    function changeOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        _dst.call.value(_value)(_data);\n    }\n}\n// to get the needed token functions in the contract\ncontract Token {\n    function transfer(address, uint) returns(bool);\n    function balanceOf(address) constant returns (uint);\n}\n\ncontract TokenSender is Owned {\n    Token public token; // the token we are working with\n    uint public totalToDistribute;\n\n    uint public next;\n\n\n    struct Transfer {\n        address addr;\n        uint amount;\n    }\n\n    Transfer[] public transfers;\n\n    function TokenSender(address _token) {\n        token = Token(_token);\n    }\n\n    // this is a used to save gas\n    uint constant D160 = 0x0010000000000000000000000000000000000000000;\n\n    // This is the function that makes the list of transfers and various\n    //  checks around that list, it is a little tricky, the data input is\n    //  structured with the `amount` and the (receiving) `addr` combined as one\n    //  long number and then this number is deconstructed in this function to\n    //  save gas and reduce the number of `0`\'s that are needed to be stored\n    //   on the blockchain\n    function fill(uint[] data) onlyOwner {\n\n        // If the send has started then we just throw\n        if (next>0) throw;\n\n        uint acc;\n        uint offset = transfers.length;\n        transfers.length = transfers.length + data.length;\n        for (uint i = 0; i < data.length; i++ ) {\n            address addr = address( data[i] & (D160-1) );\n            uint amount = data[i] / D160;\n\n            transfers[offset + i].addr = addr;\n            transfers[offset + i].amount = amount;\n            acc += amount;\n        }\n        totalToDistribute += acc;\n    }\n    // This function actually makes the sends and tracks the amount of gas used\n    //  if it takes more gas than was sent with the transaction then this\n    //  function will need to be called a few times until\n    function run() onlyOwner {\n        if (transfers.length == 0) return;\n\n        // Keep next in the stack var mNext to save gas\n        uint mNext = next;\n\n        // Set the contract as finalized to avoid reentrance\n        next = transfers.length;\n\n        if ((mNext == 0 ) && ( token.balanceOf(this) != totalToDistribute)) throw;\n\n        while ((mNext<transfers.length) && ( gas() > 150000 )) {\n            uint amount = transfers[mNext].amount;\n            address addr = transfers[mNext].addr;\n            if (amount > 0) {\n                if (!token.transfer(addr, transfers[mNext].amount)) throw;\n            }\n            mNext ++;\n        }\n\n        // Set the next to the actual state.\n        next = mNext;\n    }\n\n\n    ///////////////////////\n    // Helper functions\n    ///////////////////////\n\n    function hasTerminated() constant returns (bool) {\n        if (transfers.length == 0) return false;\n        if (next < transfers.length) return false;\n        return true;\n    }\n\n    function nTransfers() constant returns (uint) {\n        return transfers.length;\n    }\n\n    function gas() internal constant returns (uint _gas) {\n        assembly {\n            _gas:= gas\n        }\n    }\n\n}\n',
  wrappers: Set {} }

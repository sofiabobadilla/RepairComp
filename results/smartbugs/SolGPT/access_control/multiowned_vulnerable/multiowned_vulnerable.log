2024-07-04 19:01:27,739 - root - INFO - 
Reading file 'multiowned_vulnerable.sol' 

2024-07-04 19:01:27,740 - root - INFO - 
Pragma: 0.4.23 

2024-07-04 19:01:27,740 - root - INFO - 
Processing /home/mokita/sc_study/smartbugs-curated/dataset/access_control/multiowned_vulnerable.sol 

2024-07-04 19:01:27,740 - root - INFO - 
try 1/4: /home/mokita/sc_study/smartbugs-curated/dataset/access_control/multiowned_vulnerable_1round.sol  

2024-07-04 19:01:27,748 - root - INFO - 

        Docker container name: slither
        Docker image name: trailofbits/eth-security-toolbox
        Docker shared folder: /home/mokita/sc_study/smartbugs-curated/dataset:/home/ethsec/shared
        Docker command: None
         

2024-07-04 19:01:27,751 - root - INFO - 
Running command: solc-select use --always-install 0.4.23 

2024-07-04 19:01:27,915 - root - INFO - 
Running command: slither shared/access_control/multiowned_vulnerable.sol --json - 

2024-07-04 19:01:28,804 - root - INFO - 
b'{"success": true, "error": null, "results": {"detectors": [{"elements": [{"type": "pragma", "name": "^0.4.23", "source_mapping": {"start": 227, "length": 24, "filename_relative": "shared/access_control/multiowned_vulnerable.sol", "filename_absolute": "/home/ethsec/shared/access_control/multiowned_vulnerable.sol", "filename_short": "shared/access_control/multiowned_vulnerable.sol", "is_dependency": false, "lines": [7], "starting_column": 1, "ending_column": 25}, "type_specific_fields": {"directive": ["solidity", "^", "0.4", ".23"]}}], "description": "Pragma version^0.4.23 (shared/access_control/multiowned_vulnerable.sol#7) allows old versions\\n", "markdown": "Pragma version[^0.4.23](shared/access_control/multiowned_vulnerable.sol#L7) allows old versions\\n", "first_markdown_element": "shared/access_control/multiowned_vulnerable.sol#L7", "id": "2acf827681edd243a0d513b7f97592eda5eaa5a5ae827c15cf4b52e2cf30bb96", "check": "solc-version", "impact": "Informational", "confidence": "High"}, {"elements": [], "description": "solc-0.4.23 is not recommended for deployment\\n", "markdown": "solc-0.4.23 is not recommended for deployment\\n", "first_markdown_element": "", "id": "382fda39bb161fb6bd84dab76b9e9c2b52aca3c7e5a51e412552f94dbe59a506", "check": "solc-version", "impact": "Informational", "confidence": "High"}, {"elements": [{"type": "variable", "name": "_owner", "source_mapping": {"start": 895, "length": 14, "filename_relative": "shared/access_control/multiowned_vulnerable.sol", "filename_absolute": "/home/ethsec/shared/access_control/multiowned_vulnerable.sol", "filename_short": "shared/access_control/multiowned_vulnerable.sol", "is_dependency": false, "lines": [38], "starting_column": 21, "ending_column": 35}, "type_specific_fields": {"parent": {"type": "function", "name": "newOwner", "source_mapping": {"start": 877, "length": 139, "filename_relative": "shared/access_control/multiowned_vulnerable.sol", "filename_absolute": "/home/ethsec/shared/access_control/multiowned_vulnerable.sol", "filename_short": "shared/access_control/multiowned_vulnerable.sol", "is_dependency": false, "lines": [38, 39, 40, 41, 42], "starting_column": 3, "ending_column": 4}, "type_specific_fields": {"parent": {"type": "contract", "name": "MultiOwnable", "source_mapping": {"start": 284, "length": 985, "filename_relative": "shared/access_control/multiowned_vulnerable.sol", "filename_absolute": "/home/ethsec/shared/access_control/multiowned_vulnerable.sol", "filename_short": "shared/access_control/multiowned_vulnerable.sol", "is_dependency": false, "lines": [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52], "starting_column": 1, "ending_column": 2}}, "signature": "newOwner(address)"}}}, "additional_fields": {"target": "parameter", "convention": "mixedCase"}}], "description": "Parameter MultiOwnable.newOwner(address)._owner (shared/access_control/multiowned_vulnerable.sol#38) is not in mixedCase\\n", "markdown": "Parameter [MultiOwnable.newOwner(address)._owner](shared/access_control/multiowned_vulnerable.sol#L38) is not in mixedCase\\n", "first_markdown_element": "shared/access_control/multiowned_vulnerable.sol#L38", "id": "3202db02fe4740b8c68140e39a8d49f1138c0c43711cc4c9c474de5771adff32", "check": "naming-convention", "impact": "Informational", "confidence": "High"}, {"elements": [{"type": "variable", "name": "_owner", "source_mapping": {"start": 1081, "length": 14, "filename_relative": "shared/access_control/multiowned_vulnerable.sol", "filename_absolute": "/home/ethsec/shared/access_control/multiowned_vulnerable.sol", "filename_short": "shared/access_control/multiowned_vulnerable.sol", "is_dependency": false, "lines": [47], "starting_column": 24, "ending_column": 38}, "type_specific_fields": {"parent": {"type": "function", "name": "deleteOwner", "source_mapping": {"start": 1060, "length": 207, "filename_relative": "shared/access_control/multiowned_vulnerable.sol", "filename_absolute": "/home/ethsec/shared/access_control/multiowned_vulnerable.sol", "filename_short": "shared/access_control/multiowned_vulnerable.sol", "is_dependency": false, "lines": [47, 48, 49, 50, 51], "starting_column": 3, "ending_column": 4}, "type_specific_fields": {"parent": {"type": "contract", "name": "MultiOwnable", "source_mapping": {"start": 284, "length": 985, "filename_relative": "shared/access_control/multiowned_vulnerable.sol", "filename_absolute": "/home/ethsec/shared/access_control/multiowned_vulnerable.sol", "filename_short": "shared/access_control/multiowned_vulnerable.sol", "is_dependency": false, "lines": [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52], "starting_column": 1, "ending_column": 2}}, "signature": "deleteOwner(address)"}}}, "additional_fields": {"target": "parameter", "convention": "mixedCase"}}], "description": "Parameter MultiOwnable.deleteOwner(address)._owner (shared/access_control/multiowned_vulnerable.sol#47) is not in mixedCase\\n", "markdown": "Parameter [MultiOwnable.deleteOwner(address)._owner](shared/access_control/multiowned_vulnerable.sol#L47) is not in mixedCase\\n", "first_markdown_element": "shared/access_control/multiowned_vulnerable.sol#L47", "id": "58d0f3a6a15214343a6c515a37da463cfdb33c6de443e8d3693edd4dafa6e78d", "check": "naming-convention", "impact": "Informational", "confidence": "High"}]}}\n' 

2024-07-04 19:01:33,909 - root - INFO - 
NEW CODE: 1. In the `newOwner` function, the condition `require(_owner != 0);` should be changed to `require(_owner != address(0));` to check for the zero address correctly.

2. In the `deleteOwner` function, the condition `require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));` should be changed to `require(owners[_owner] == msg.sender || (owners[_owner] != address(0) && msg.sender == root));` to check for the zero address correctly.

Here is the fixed contract:

```solidity
pragma solidity ^0.4.23;

contract MultiOwnable {
    address public root;
    mapping (address => address) public owners; 

    constructor() public {
        root = msg.sender;
        owners[root] = root;
    }

    modifier onlyOwner() {
        require(owners[msg.sender] != address(0));
        _;
    }

    function newOwner(address _owner) external returns (bool) {
        require(_owner != address(0));
        owners[_owner] = msg.sender;
        return true;
    }

    function deleteOwner(address _owner) onlyOwner external returns (bool) {
        require(owners[_owner] == msg.sender || (owners[_owner] != address(0) && msg.sender == root));
        owners[_owner] = address(0);
        return true;
    }
}

contract TestContract is MultiOwnable {
    function withdrawAll() onlyOwner {
        msg.sender.transfer(this.balance);
    }

    function() payable {
    }
}
``` 

2024-07-04 19:01:33,910 - root - INFO - 
try 2/4: /home/mokita/sc_study/smartbugs-curated/dataset/access_control/multiowned_vulnerable_2round.sol  

2024-07-04 19:01:38,514 - root - INFO - 
NEW CODE: 1. In the `newOwner` function, the condition `require(_owner != 0);` should be changed to `require(_owner != address(0));` to check for the zero address correctly.

2. In the `deleteOwner` function, the condition `require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));` should be changed to `require(owners[_owner] == msg.sender || (owners[_owner] != address(0) && msg.sender == root));` to check for the zero address correctly.

Here is the fixed contract:

```solidity
pragma solidity ^0.4.23;

contract MultiOwnable {
    address public root;
    mapping (address => address) public owners; 

    constructor() public {
        root = msg.sender;
        owners[root] = root;
    }

    modifier onlyOwner() {
        require(owners[msg.sender] != address(0));
        _;
    }

    function newOwner(address _owner) external returns (bool) {
        require(_owner != address(0));
        owners[_owner] = msg.sender;
        return true;
    }

    function deleteOwner(address _owner) onlyOwner external returns (bool) {
        require(owners[_owner] == msg.sender || (owners[_owner] != address(0) && msg.sender == root));
        owners[_owner] = address(0);
        return true;
    }
}

contract TestContract is MultiOwnable {
    function withdrawAll() onlyOwner {
        msg.sender.transfer(this.balance);
    }

    function() payable {
    }
}
``` 

2024-07-04 19:01:38,515 - root - INFO - 
try 3/4: /home/mokita/sc_study/smartbugs-curated/dataset/access_control/multiowned_vulnerable_3round.sol  

2024-07-04 19:01:42,641 - root - INFO - 
NEW CODE: 1. In the `newOwner` function, the condition `require(_owner != 0);` should be changed to `require(_owner != address(0));` to check for the zero address correctly.

2. In the `deleteOwner` function, the condition `require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));` should be changed to `require(owners[_owner] == msg.sender || (owners[_owner] != address(0) && msg.sender == root));` to check for the zero address correctly.

Here is the fixed contract:

```solidity
pragma solidity ^0.4.23;

contract MultiOwnable {
    address public root;
    mapping (address => address) public owners; 

    constructor() public {
        root = msg.sender;
        owners[root] = root;
    }

    modifier onlyOwner() {
        require(owners[msg.sender] != address(0));
        _;
    }

    function newOwner(address _owner) external returns (bool) {
        require(_owner != address(0));
        owners[_owner] = msg.sender;
        return true;
    }

    function deleteOwner(address _owner) onlyOwner external returns (bool) {
        require(owners[_owner] == msg.sender || (owners[_owner] != address(0) && msg.sender == root));
        owners[_owner] = address(0);
        return true;
    }
}

contract TestContract is MultiOwnable {
    function withdrawAll() onlyOwner {
        msg.sender.transfer(this.balance);
    }

    function() payable {
    }
}
``` 

2024-07-04 19:01:42,642 - root - INFO - 
try 4/4: /home/mokita/sc_study/smartbugs-curated/dataset/access_control/multiowned_vulnerable_4round.sol  

2024-07-04 19:01:47,833 - root - INFO - 
NEW CODE: 1. In the `newOwner` function, the condition `require(_owner != 0);` should be changed to `require(_owner != address(0));` to check for the zero address correctly.

2. In the `deleteOwner` function, the condition `require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));` should be changed to `require(owners[_owner] == msg.sender || (owners[_owner] != address(0) && msg.sender == root));` to check for the zero address correctly.

Here is the fixed contract:

```solidity
pragma solidity ^0.4.23;

contract MultiOwnable {
    address public root;
    mapping (address => address) public owners; 

    constructor() public {
        root = msg.sender;
        owners[root] = root;
    }

    modifier onlyOwner() {
        require(owners[msg.sender] != address(0));
        _;
    }

    function newOwner(address _owner) external returns (bool) {
        require(_owner != address(0));
        owners[_owner] = msg.sender;
        return true;
    }

    function deleteOwner(address _owner) onlyOwner external returns (bool) {
        require(owners[_owner] == msg.sender || (owners[_owner] != address(0) && msg.sender == root));
        owners[_owner] = address(0);
        return true;
    }
}

contract TestContract is MultiOwnable {
    function withdrawAll() onlyOwner {
        msg.sender.transfer(this.balance);
    }

    function() payable {
    }
}
``` 


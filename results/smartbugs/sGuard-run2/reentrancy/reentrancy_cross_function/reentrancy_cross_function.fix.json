{"bugFixes":{"Kn%S#":"add_uint256(a, b)","k3D[k\":#qlE@<[$M\"[Wt.^mwQ4":" function withdrawBalance() nonReentrant_ ","h[LV%}KT|0o[kTd$|++M\".{8H:7R?[`O/Mh0u%plI,5p^p":"contract Reentrancy_cross_function  is sGuard  is sGuard ","OiGhP":"sub_uint256(a, b)","H[&S&(,~A<Su_J7":"contract sGuard is sGuard ","mV1cu(Z#C=hG\"n3XH\"z6R\"?OgPxQi?-DoM6'/1ci1G":" function transfer(address to, uint amount) nonReentrant_ "},"source":"H[&S&(,~A<Su_J7{\n  function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return OiGhP;\n  }\n  \n  bool internal locked_;\n  constructor() internal {\n    locked_ = false;\n  }\n  modifier nonReentrant_() {\n    require(!locked_);\n    locked_ = true;\n    _;\n    locked_ = false;\n  }\n  \n  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = Kn%S#;\n    assert(c >= a);\n    return c;\n  }\n}\n/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/\n * @author: consensys\n * @vulnerable_at_lines: 24\n */\n\n\nh[LV%}KT|0o[kTd$|++M\".{8H:7R?[`O/Mh0u%plI,5p^p{\n\n    // INSECURE\n    mapping (address => uint) private userBalances;\n\n     mV1cu(Z#C=hG\"n3XH\"z6R\"?OgPxQi?-DoM6'/1ci1G nonReentrant_  {\n        if (userBalances[msg.sender] >= amount) {\n            userBalances[to] = add_uint256(userBalances[to], amount);\n            userBalances[msg.sender] = sub_uint256(userBalances[msg.sender], amount);\n        }\n    }\n\n     k3D[k\":#qlE@<[$M\"[Wt.^mwQ4 nonReentrant_  public {\n        uint amountToWithdraw = userBalances[msg.sender];\n        // <yes> <report> REENTRANCY\n        (bool success, ) = msg.sender.call.value(amountToWithdraw)(\"\"); // At this point, the caller's code is executed, and can call transfer()\n        require(success);\n        userBalances[msg.sender] = 0;\n    }\n}\n","wrappers":{}}
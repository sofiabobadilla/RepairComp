
> symEvm@1.0.0 dev /sGuard
> node src/index.js "patches/reentrancy/reentrancy_simple/reentrancy_simple.sol" "report_run/reentrancy/reentrancy_simple" "Reentrance"

patches/reentrancy/reentrancy_simple/reentrancy_simple.sol
{ bugFixes:
   { '{[Tt8': 'add_uint256(a, b)',
     'nDXWD"uKnutX3L!>`A5?;MN': ' function addToBalance() nonReentrant_ ',
     '\\vuR{ebnU+F>K,+': 'contract sGuard is sGuard ',
     'Ux(9.Clv{0u\'k]lDPZz$>UDn?%': ' function withdrawBalance() nonReentrant_ ',
     'Fc6o6_i`@-8]K{PLyJY2u}g\\oqQ^$ES': 'contract Reentrance  is sGuard  is sGuard ' },
  source:
   '\\vuR{ebnU+F>K,+{\n  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = {[Tt8;\n    assert(c >= a);\n    return c;\n  }\n  \n  bool internal locked_;\n  constructor() internal {\n    locked_ = false;\n  }\n  modifier nonReentrant_() {\n    require(!locked_);\n    locked_ = true;\n    _;\n    locked_ = false;\n  }\n}\n/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/reentrancy/Reentrancy.sol\n * @author: -\n * @vulnerable_at_lines: 24\n */\n\n\n Fc6o6_i`@-8]K{PLyJY2u}g\\oqQ^$ES{\n     mapping (address => uint) userBalance;\n\n     function getBalance(address u) constant returns(uint){\n         return userBalance[u];\n     }\n\n      nDXWD"uKnutX3L!>`A5?;MN nonReentrant_  payable{\n         userBalance[msg.sender] = add_uint256(userBalance[msg.sender], msg.value);\n     }\n\n      Ux(9.Clv{0u\'k]lDPZz$>UDn?% nonReentrant_ {\n         // send userBalance[msg.sender] ethers to msg.sender\n         // if mgs.sender is a contract, it will call its fallback function\n         // <yes> <report> REENTRANCY\n         if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n             throw;\n         }\n         userBalance[msg.sender] = 0;\n     }\n }\n',
  wrappers: Set { 'add_uint256', 'nonReentrant_' } }

{"bugFixes":{"mD!WY":"div_uint256(c, a)","<$3WXVw'...c_TNJu+kd~j:A=_M1fY":"contract OpenAddressLottery is sGuard, ","nG1?b":"mul_uint256(a, b)","K!QuQAm+<NG@B%6":"contract sGuard is sGuard "},"source":"K!QuQAm+<NG@B%6{\n  function mul_uint256(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = nG1?b;\n    assert(mD!WY == b);\n    return c;\n  }\n}\n/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * @vulnerable_at_lines: 91\n */\n\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\n<$3WXVw'...c_TNJu+kd~j:A=_M1fY sGuard {\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    function OpenAddressLottery() {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=mul_uint256(msg.value, 7); //win = 7 times the ticket price\n            \n            if(win>this.balance) //if the balance isnt sufficient...\n                win=this.balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) constant returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(keccak256(uint(addr), secretSeed)[0]) % 8;\n    }\n    \n    function reseed(SeedComponents components) internal {\n        secretSeed = uint256(keccak256(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        )); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(block.blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = mul_uint256(tx.gasprice, 7);\n        \n        reseed(s); //reseed\n    }\n    \n    function () payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}","wrappers":{}}
{"bugFixes":{"h^%yc":"add_uint256(a, b)","6hICz@,rN\"yj%Y,6qfx`|ZSH!!h}N8[<>WJtq(upW5~}^+O=79f":" function WithdrawToHolder(address _addr, uint _wei) nonReentrant_ ","jr5Ry1W|e>__DiR))s:N_.*Bp\"eCr#,<?2vC2t9aks@Z&qMB'DGc]_L\"i%W@\\[^86yoc@e":" function WitdrawTokenToHolder(address _to,address _token,uint _amount) nonReentrant_ ","/j8]X/!`>GEw3i/})o":" function Deposit() nonReentrant_ ","Y`eRfzG!AyWa%:nUZ6(=a":"contract TokenBank is sGuard, ","<`jQ$F:X0=`([NP>WnDNsg@}&r`]":"contract Ownable\n is sGuard  is sGuard ","7?tAz":"sub_uint256(a, b)","l?nfj1TteT/(wA3\"&PHkoAg~`0/~#Pa\\3r":" function changeOwner(address addr) nonReentrant_ ","8AqgR}(vs8d`))ELA":"contract Token is sGuard, ","E++0b@gwKZvmV^~5;!+>#`d":" function confirmOwner() nonReentrant_ ","ib$XIQOF,23Kp/s":"contract sGuard is sGuard ","!i[BQL}ECG##5wNOn|\"EN'+=":" function initTokenBank() nonReentrant_ "},"source":"ib$XIQOF,23Kp/s{\n  function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return 7?tAz;\n  }\n  \n  bool internal locked_;\n  constructor() internal {\n    locked_ = false;\n  }\n  modifier nonReentrant_() {\n    require(!locked_);\n    locked_ = true;\n    _;\n    locked_ = false;\n  }\n  \n  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = h^%yc;\n    assert(c >= a);\n    return c;\n  }\n}\n/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\n\n<`jQ$F:X0=`([NP>WnDNsg@}&r`]{\n    address newOwner;\n    address owner = msg.sender;\n    \n     l?nfj1TteT/(wA3\"&PHkoAg~`0/~#Pa\\3r nonReentrant_ \n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n     E++0b@gwKZvmV^~5;!+>#`d nonReentrant_  \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\n8AqgR}(vs8d`))ELA sGuard,  Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n         // <yes> <report> UNCHECKED_LL_CALLS\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\nY`eRfzG!AyWa%:nUZ6(=a sGuard,  Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n     !i[BQL}ECG##5wNOn|\"EN'+= nonReentrant_ \n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n     /j8]X/!`>GEw3i/})o nonReentrant_  \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender] = add_uint256(Holders[msg.sender], msg.value);\n        }\n    }\n    \n     jr5Ry1W|e>__DiR))s:N_.*Bp\"eCr#,<?2vC2t9aks@Z&qMB'DGc]_L\"i%W@\\[^86yoc@e nonReentrant_ \n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n     6hICz@,rN\"yj%Y,6qfx`|ZSH!!h}N8[<>WJtq(upW5~}^+O=79f nonReentrant_  \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[_addr]>0)\n        {\n            if(_addr.call.value(_wei)())\n            {\n                Holders[_addr] = sub_uint256(Holders[_addr], _wei);\n            }\n        }\n    }\n}","wrappers":{}}
{"bugFixes":{"WRq1{":"div_uint256(a, b)","$uePm":"mul_uint256(a, b)","v(#!L":"sub_uint64(a, b)","9<>#/A[*XXPo;\"4_9Oz_;G_\"#EzlSDlNb":" function upgrade(address newAddr) nonReentrant_ ","]t0B~4aI$$m!R?1M/VDpw#=8`:$i~pV4=8m77HbVjJAXT4)j-t>?5TJ-h4q(2":" function reset(uint price, uint minGas, uint cancellationGas) nonReentrant_ ","w8k?3z]k*K7B$~^ELljF|nmviV[pngcf3":" function cancel(uint64 requestId) nonReentrant_ ","1H<!U{Rnl,u!S?zk7Y":" function suspend() nonReentrant_ ","D<`i/zP`=_mySCe":"contract sGuard is sGuard ","`(XIw":"div_uint256(c, a)","qN]C0":"sub_uint256(a, b)","O\\]Vm6x8U,.MJ{Ao3FAdph_oc#~zVAMAuj6g22w?9zn(~uB8\".Jk*~6zkozqDt5pMF-C!$\\d>h`L^q!Km7Tm20":" function deliver(uint64 requestId, bytes32 paramsHash, uint64 error, bytes32 respData) nonReentrant_ ",";^[1!YLNt@Krf?O>q\\l2mV`AHB0XB<":"contract TownCrier  is sGuard  is sGuard ","#nxub":"add_uint64(a, b)","vWe*&u+V]/q%D~,HfV`USsd1/$c-8W`QC\\}|ND6Z5U>-DJ.b-6y\"4[q;#L]o9}BA^KGmL_g15#JOZ9cLG0Zt|,|-EV]*uP4n$ep/eScn!eYLk`26vkE)":" function request(uint8 requestType, address callbackAddr, bytes4 callbackFID, uint timestamp, bytes32[] requestData) nonReentrant_ ","/w}Hc#sw.i^'}cU[j<":" function restart() nonReentrant_ "},"source":"D<`i/zP`=_mySCe{\n  function sub_uint256(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return qN]C0;\n  }\n  \n  function sub_uint64(uint64 a, uint64 b) internal pure returns (uint64) {\n    assert(b <= a);\n    return v(#!L;\n  }\n  \n  function add_uint64(uint64 a, uint64 b) internal pure returns (uint64) {\n    uint64 c = #nxub;\n    assert(c >= a);\n    return c;\n  }\n  \n  function mul_uint256(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = $uePm;\n    assert(`(XIw == b);\n    return c;\n  }\n  \n  bool internal locked_;\n  constructor() internal {\n    locked_ = false;\n  }\n  modifier nonReentrant_() {\n    require(!locked_);\n    locked_ = true;\n    _;\n    locked_ = false;\n  }\n  \n  function div_uint256(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = WRq1{;\n    return c;\n  }\n}\n/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 162,175,180,192\n */\n\n\n;^[1!YLNt@Krf?O>q\\l2mV`AHB0XB<{\n    struct Request { // the data structure for each request\n        address requester; // the address of the requester\n        uint fee; // the amount of wei the requester pays for the request\n        address callbackAddr; // the address of the contract to call for delivering response\n        bytes4 callbackFID; // the specification of the callback function\n        bytes32 paramsHash; // the hash of the request parameters\n    }\n   \n    event Upgrade(address newAddr);\n    event Reset(uint gas_price, uint min_fee, uint cancellation_fee); \n    event RequestInfo(uint64 id, uint8 requestType, address requester, uint fee, address callbackAddr, bytes32 paramsHash, uint timestamp, bytes32[] requestData); // log of requests, the Town Crier server watches this event and processes requests\n    event DeliverInfo(uint64 requestId, uint fee, uint gasPrice, uint gasLeft, uint callbackGas, bytes32 paramsHash, uint64 error, bytes32 respData); // log of responses\n    event Cancel(uint64 requestId, address canceller, address requester, uint fee, int flag); // log of cancellations\n\n    address public constant SGX_ADDRESS = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593;// address of the SGX account\n\n    uint public GAS_PRICE = 5 * 10**10;\n    uint public MIN_FEE = 30000 * GAS_PRICE; // minimum fee required for the requester to pay such that SGX could call deliver() to send a response\n    uint public CANCELLATION_FEE = 25000 * GAS_PRICE; // charged when the requester cancels a request that is not responded\n\n    uint public constant CANCELLED_FEE_FLAG = 1;\n    uint public constant DELIVERED_FEE_FLAG = 0;\n    int public constant FAIL_FLAG = -2 ** 250;\n    int public constant SUCCESS_FLAG = 1;\n\n    bool public killswitch;\n\n    bool public externalCallFlag;\n\n    uint64 public requestCnt;\n    uint64 public unrespondedCnt;\n    Request[2**64] public requests;\n\n    int public newVersion = 0;\n\n    // Contracts that receive Ether but do not define a fallback function throw\n    // an exception, sending back the Ether (this was different before Solidity\n    // v0.4.0). So if you want your contract to receive Ether, you have to\n    // implement a fallback function.\n    function () {}\n\n    function TownCrier() public {\n        // Start request IDs at 1 for two reasons:\n        //   1. We can use 0 to denote an invalid request (ids are unsigned)\n        //   2. Storage is more expensive when changing something from zero to non-zero,\n        //      so this means the first request isn't randomly more expensive.\n        requestCnt = 1;\n        requests[0].requester = msg.sender;\n        killswitch = false;\n        unrespondedCnt = 0;\n        externalCallFlag = false;\n    }\n\n     9<>#/A[*XXPo;\"4_9Oz_;G_\"#EzlSDlNb nonReentrant_  {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            newVersion = -int(newAddr);\n            killswitch = true;\n            Upgrade(newAddr);\n        }\n    }\n\n     ]t0B~4aI$$m!R?1M/VDpw#=8`:$i~pV4=8m77HbVjJAXT4)j-t>?5TJ-h4q(2 nonReentrant_  public {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            GAS_PRICE = price;\n            MIN_FEE = mul_uint256(price, minGas);\n            CANCELLATION_FEE = mul_uint256(price, cancellationGas);\n            Reset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);\n        }\n    }\n\n     1H<!U{Rnl,u!S?zk7Y nonReentrant_  public {\n        if (msg.sender == requests[0].requester) {\n            killswitch = true;\n        }\n    }\n\n     /w}Hc#sw.i^'}cU[j< nonReentrant_  public {\n        if (msg.sender == requests[0].requester && newVersion == 0) {\n            killswitch = false;\n        }\n    }\n\n    function withdraw() public {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            if (!requests[0].requester.call.value(this.balance)()) {\n                throw;\n            }\n        }\n    }\n\n     vWe*&u+V]/q%D~,HfV`USsd1/$c-8W`QC\\}|ND6Z5U>-DJ.b-6y\"4[q;#L]o9}BA^KGmL_g15#JOZ9cLG0Zt|,|-EV]*uP4n$ep/eScn!eYLk`26vkE) nonReentrant_  public payable returns (int) {\n        if (externalCallFlag) {\n            throw;\n        }\n\n        if (killswitch) {\n            externalCallFlag = true;\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            return newVersion;\n        }\n\n        if (msg.value < MIN_FEE) {\n            externalCallFlag = true;\n            // If the amount of ether sent by the requester is too little or \n            // too much, refund the requester and discard the request.\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            return FAIL_FLAG;\n        } else {\n            // Record the request.\n            uint64 requestId = requestCnt;\n            (requestCnt = add_uint64(requestCnt, 1));\n            (unrespondedCnt = add_uint64(unrespondedCnt, 1));\n\n            bytes32 paramsHash = sha3(requestType, requestData);\n            requests[requestId].requester = msg.sender;\n            requests[requestId].fee = msg.value;\n            requests[requestId].callbackAddr = callbackAddr;\n            requests[requestId].callbackFID = callbackFID;\n            requests[requestId].paramsHash = paramsHash;\n\n            // Log the request for the Town Crier server to process.\n            RequestInfo(requestId, requestType, msg.sender, msg.value, callbackAddr, paramsHash, timestamp, requestData);\n            return requestId;\n        }\n    }\n\n     O\\]Vm6x8U,.MJ{Ao3FAdph_oc#~zVAMAuj6g22w?9zn(~uB8\".Jk*~6zkozqDt5pMF-C!$\\d>h`L^q!Km7Tm20 nonReentrant_  public {\n        if (msg.sender != SGX_ADDRESS ||\n                requestId <= 0 ||\n                requests[requestId].requester == 0 ||\n                requests[requestId].fee == DELIVERED_FEE_FLAG) {\n            // If the response is not delivered by the SGX account or the \n            // request has already been responded to, discard the response.\n            return;\n        }\n\n        uint fee = requests[requestId].fee;\n        if (requests[requestId].paramsHash != paramsHash) {\n            // If the hash of request parameters in the response is not \n            // correct, discard the response for security concern.\n            return;\n        } else if (fee == CANCELLED_FEE_FLAG) {\n            // If the request is cancelled by the requester, cancellation \n            // fee goes to the SGX account and set the request as having\n            // been responded to.\n            // <yes> <report> UNCHECKED_LL_CALLS\n            SGX_ADDRESS.send(CANCELLATION_FEE);\n            requests[requestId].fee = DELIVERED_FEE_FLAG;\n            (unrespondedCnt = sub_uint64(unrespondedCnt, 1));\n            return;\n        }\n\n        requests[requestId].fee = DELIVERED_FEE_FLAG;\n        (unrespondedCnt = sub_uint64(unrespondedCnt, 1));\n\n        if (error < 2) {\n            // Either no error occurs, or the requester sent an invalid query.\n            // Send the fee to the SGX account for its delivering.\n            // <yes> <report> UNCHECKED_LL_CALLS\n            SGX_ADDRESS.send(fee);         \n        } else {\n            // Error in TC, refund the requester.\n            externalCallFlag = true;\n            // <yes> <report> UNCHECKED_LL_CALLS\n            requests[requestId].requester.call.gas(2300).value(fee)();\n            externalCallFlag = false;\n        }\n\n        uint callbackGas = div_uint256((sub_uint256(fee, MIN_FEE)), tx.gasprice); // gas left for the callback function\n        DeliverInfo(requestId, fee, tx.gasprice, msg.gas, callbackGas, paramsHash, error, respData); // log the response information\n        if (callbackGas > sub_uint256(msg.gas, 5000)) {\n            callbackGas = sub_uint256(msg.gas, 5000);\n        }\n        \n        externalCallFlag = true;\n        // <yes> <report> UNCHECKED_LL_CALLS\n        requests[requestId].callbackAddr.call.gas(callbackGas)(requests[requestId].callbackFID, requestId, error, respData); // call the callback function in the application contract\n        externalCallFlag = false;\n    }\n\n     w8k?3z]k*K7B$~^ELljF|nmviV[pngcf3 nonReentrant_  public returns (int) {\n        if (externalCallFlag) {\n            throw;\n        }\n\n        if (killswitch) {\n            return 0;\n        }\n\n        uint fee = requests[requestId].fee;\n        if (requests[requestId].requester == msg.sender && fee >= CANCELLATION_FEE) {\n            // If the request was sent by this user and has money left on it,\n            // then cancel it.\n            requests[requestId].fee = CANCELLED_FEE_FLAG;\n            externalCallFlag = true;\n            if (!msg.sender.call.value(sub_uint256(fee, CANCELLATION_FEE))()) {\n                throw;\n            }\n            externalCallFlag = false;\n            Cancel(requestId, msg.sender, requests[requestId].requester, requests[requestId].fee, 1);\n            return SUCCESS_FLAG;\n        } else {\n            Cancel(requestId, msg.sender, requests[requestId].requester, fee, -1);\n            return FAIL_FLAG;\n        }\n    }\n}","wrappers":{}}
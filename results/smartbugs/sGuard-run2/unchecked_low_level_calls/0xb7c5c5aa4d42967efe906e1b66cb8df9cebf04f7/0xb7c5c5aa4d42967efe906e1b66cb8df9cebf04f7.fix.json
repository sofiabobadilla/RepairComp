{"bugFixes":{",t'DM":"add_uint256(a, b)","FW;%&+ArJ[^[kvMCy?z&zg=GE1(:X@]x":"contract keepMyEther  is sGuard  is sGuard ","3(oGCL%z5T#Z*ID-z5Q":" function withdraw() nonReentrant_ ","7&wTkZF4l:ot4m=":"contract sGuard is sGuard "},"source":"7&wTkZF4l:ot4m={\n  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = ,t'DM;\n    assert(c >= a);\n    return c;\n  }\n  \n  bool internal locked_;\n  constructor() internal {\n    locked_ = false;\n  }\n  modifier nonReentrant_() {\n    require(!locked_);\n    locked_ = true;\n    _;\n    locked_ = false;\n  }\n}\n/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 25\n */\n\n\n/*\n!!! THIS CONTRACT IS EXPLOITABLE AND FOR EDUCATIONAL PURPOSES ONLY !!!\n\nThis smart contract allows a user to (insecurely) store funds\nin this smart contract and withdraw them at any later point in time\n*/\n\nFW;%&+ArJ[^[kvMCy?z&zg=GE1(:X@]x{\n    mapping(address => uint256) public balances;\n    \n    function () payable public {\n        balances[msg.sender] = add_uint256(balances[msg.sender], msg.value);\n    }\n    \n     3(oGCL%z5T#Z*ID-z5Q nonReentrant_  public {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}","wrappers":{}}
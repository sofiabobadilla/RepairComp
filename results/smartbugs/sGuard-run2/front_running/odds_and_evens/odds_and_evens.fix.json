{"bugFixes":{"uo^p?":"add_uint8(a, b)","2U4sQ9+g\\ZJF\\<52)$@\"A(jI%L":" function play(uint number) nonReentrant_ ","!MT/.:{-yui!UrA":"contract sGuard is sGuard ","g<PN[":"add_uint256(a, b)","N<{a:z3E]A;uIvOb+J0JG}-(":"contract OddsAndEvens is sGuard, "},"source":"!MT/.:{-yui!UrA{\n  function add_uint256(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = g<PN[;\n    assert(c >= a);\n    return c;\n  }\n  \n  bool internal locked_;\n  constructor() internal {\n    locked_ = false;\n  }\n  modifier nonReentrant_() {\n    require(!locked_);\n    locked_ = true;\n    _;\n    locked_ = false;\n  }\n  \n  function add_uint8(uint8 a, uint8 b) internal pure returns (uint8) {\n    uint8 c = uo^p?;\n    assert(c >= a);\n    return c;\n  }\n}\n/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#oddsandevens\n * @author: -\n * @vulnerable_at_lines: 25,28\n */\n\n\nN<{a:z3E]A;uIvOb+J0JG}-( sGuard {\n\n  struct Player {\n    address addr;\n    uint number;\n  }\n\n  Player[2] public players;         //public only for debug purpose\n\n  uint8 tot;\n  address owner;\n\n  function OddsAndEvens() {\n    owner = msg.sender;\n  }\n// <yes> <report> FRONT_RUNNING\n   2U4sQ9+g\\ZJF\\<52)$@\"A(jI%L nonReentrant_  payable{\n    if (msg.value != 1 ether) throw;\n    // <yes> <report> FRONT_RUNNING\n    players[tot] = Player(msg.sender, number);\n    (tot = add_uint8(tot, 1));\n\n    if (tot==2) andTheWinnerIs();\n  }\n\n  function andTheWinnerIs() private {\n    bool res ;\n    uint n = add_uint256(players[0].number, players[1].number);\n    if (n%2==0) {\n      res = players[0].addr.send(1800 finney);\n    }\n    else {\n      res = players[1].addr.send(1800 finney);\n    }\n\n    delete players;\n    tot=0;\n  }\n\n  function getProfit() {\n    if(msg.sender!=owner) throw;\n    bool res = msg.sender.send(this.balance);\n  }\n\n}\n","wrappers":{}}